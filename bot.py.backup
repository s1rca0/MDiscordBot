# bot.py
import os
import asyncio
import logging
from typing import Optional

import discord
from discord.ext import commands
from discord import app_commands

from ai_provider import ai_reply  # HF ↔ OpenAI switch
from config import BotConfig

cfg = BotConfig()
cfg.validate_config()

log = logging.getLogger(__name__)

class DiscordBot:
    def __init__(self):
        self._synced = False
        # Intents
        intents = discord.Intents.default()
        intents.message_content = True   # needed to read message text
        intents.members = True           # for join events / greetings

        # Create commands.Bot so we can do slash + events
        self.bot = commands.Bot(
            command_prefix="!",
            intents=intents,
            description="AI Discord Bot (HF dev, OpenAI-ready)"
        )

        # Wire events/commands
        self._register_events()
        self._register_app_commands()

    # ----------------- public API used by main.py -----------------
    async def start_bot(self):
        token = cfg.BOT_TOKEN
        if not token:
            raise RuntimeError("Missing DISCORD_BOT_TOKEN env var")
        await self.bot.start(token)

    # ----------------- events & commands -----------------
    def _register_events(self):
        @self.bot.event
        async def on_ready():
            try:
                synced = await self.bot.tree.sync()
                log.info("Synced %d commands: %s", len(synced), [c.name for c in synced])
            except Exception as e:
                log.warning("Slash command sync failed: %s", e)
            log.info("✅ Logged in as %s (%s)", self.bot.user, self.bot.user.id)

      #  @self.bot.event
        async def on_member_join(member: discord.Member):
            # Greet publicly if possible
            ch = member.guild.system_channel
            if ch:
                try:
                    await ch.send(
                        f"Welcome {member.mention}! I’m {self.bot.user.name} — ping me or use /ask to chat."
                    )
                except Exception:
                    pass
            # DM greeting (may fail if DMs are blocked)
            try:
                await member.send(
                    f"Hi {member.display_name}! I’m {self.bot.user.name}. "
                    f"Type /ask in the server or DM me here."
                )
            except Exception:
                pass

        @self.bot.event
        async def on_message(message: discord.Message):
            # Keep other commands working
            if message.author.bot:
                return

            # Trigger policy: reply in DMs, or when mentioned in a guild
            trigger = (message.guild is None) or (self.bot.user in message.mentions)
            if not trigger:
                return

            # Clean mention text in guilds
            content = message.content
            if message.guild is not None:
                content = content.replace(f"<@{self.bot.user.id}>", "").strip()
                content = content.replace(f"<@!{self.bot.user.id}>", "").strip()
            if not content:
                content = "Say hi."

            try:
                reply = await ai_reply(
                    cfg.SYSTEM_PROMPT,
                    [{"role": "user", "content": content}],
                    max_new_tokens=cfg.AI_MAX_NEW_TOKENS,
                    temperature=cfg.AI_TEMPERATURE
                )
            except Exception as e:
                log.exception("AI error: %s", e)
                reply = "Sorry, I hit an error. Try again."
            if not reply or not reply.strip():
                reply = "I’m here—try asking me again."
            await message.channel.send(reply[:1900])
            # Allow prefixed commands to run too
            await self.bot.process_commands(message)

    def _register_app_commands(self):
        @self.bot.tree.command(name="ask", description="Ask the AI a question")
        @app_commands.describe(prompt="Your question or prompt")
        async def ask(interaction: discord.Interaction, prompt: str):
            await interaction.response.defer()
            try:
                reply = await ai_reply(
                    cfg.SYSTEM_PROMPT,
                    [{"role": "user", "content": prompt}],
                    max_new_tokens=cfg.AI_MAX_NEW_TOKENS,
                    temperature=cfg.AI_TEMPERATURE
                )
            except Exception as e:
                log.exception("AI error: %s", e)
                reply = "Sorry, I couldn’t get a response."
                if not reply or not reply.strip():
                    reply = "I’m here—try asking me again."
            await interaction.followup.send(reply[:1900])